diff --git a/@astrojs__starlight@0.32.0.patch b/@astrojs__starlight@0.32.0.patch
new file mode 100644
index 0000000000000000000000000000000000000000..a73b0d84d6c625eedd4257b56fce489337d59a6e
--- /dev/null
+++ b/@astrojs__starlight@0.32.0.patch
@@ -0,0 +1,332 @@
+diff --git a/utils/createPathFormatter.ts b/utils/createPathFormatter.ts
+index 52c9527c6d8c6756125c2f746cf14d055ed1e3ef..8dd709f556b94a578636835ea9a9382921dfe3eb 100644
+--- a/utils/createPathFormatter.ts
++++ b/utils/createPathFormatter.ts
+@@ -37,9 +37,15 @@ function formatPath(
+ 	href: string,
+ 	{ format = 'directory', trailingSlash = 'ignore' }: FormatPathOptions
+ ) {
++	const segments = href.split('/');
+ 	const formatStrategy = formatStrategies[format];
+ 	const trailingSlashStrategy = trailingSlashStrategies[trailingSlash];
+ 
++	if (segments[1] === segments[3]) {
++	  segments.splice(3, 1);
++	  href = segments.join('/')
++	}	
++
+ 	// Handle extension
+ 	href = formatStrategy.handleExtension(href);
+ 
+diff --git a/utils/navigation.ts b/utils/navigation.ts
+index cfcd2e837d328fb0f15c7706862f115a184e2ff3..fa528c286149ab9543bc5a8582675f33f0873c1a 100644
+--- a/utils/navigation.ts
++++ b/utils/navigation.ts
+@@ -224,10 +224,35 @@ function getRoutePathRelativeToCollectionRoot(route: Route, locale: string | und
+ 			localizedId(route.entry.filePath.replace(`${docsCollectionPathFromRoot}/`, ''), locale);
+ }
+ 
++function cleanSegment(path: string): string {
++    let segments = path.split('/');
++    if (segments[0] === segments[2]) {
++        segments.splice(2, 1);  // Remove the third segment (index 2)
++    }
++    return segments.join('/');  // Join the segments back into a string
++}
++
+ /** Turn a flat array of routes into a tree structure. */
+ function treeify(routes: Route[], locale: string | undefined, baseDir: string): Dir {
+ 	const treeRoot: Dir = makeDir(baseDir);
+-	routes
++
++	const testRoutes = routes.map(item => {
++    		let newItem = {...item, entry: {...item.entry}};
++
++			if (newItem.id) newItem.id = cleanSegment(newItem.id);
++    		if (newItem.slug) newItem.slug = cleanSegment(newItem.slug);
++
++    		// Also handle id and slug inside entry if it exists
++    		if (newItem.entry) {
++    		    newItem.entry = { ...newItem.entry };
++    		    newItem.entry.id = cleanSegment(newItem.entry.id);
++    		    newItem.entry.slug = cleanSegment(newItem.entry.slug);
++    		}
++
++    		return newItem; 
++		}) 
++		
++	testRoutes
+ 		// Remove any entries that should be hidden
+ 		.filter((doc) => !doc.entry.data.sidebar.hidden)
+ 		// Compute the path of each entry from the root of the collection ahead of time.
+diff --git a/utils/routing/index.ts b/utils/routing/index.ts
+index 460d15a778f3ea47e8df62bf8d217edf4b482e34..79248ae4a64c608b7b72577b8b6670f6ffa592e2 100644
+--- a/utils/routing/index.ts
++++ b/utils/routing/index.ts
+@@ -1,20 +1,29 @@
+-import type { GetStaticPathsItem } from 'astro';
+-import { getCollection } from 'astro:content';
+-import config from 'virtual:starlight/user-config';
+-import project from 'virtual:starlight/project-context';
+-import { getCollectionPathFromRoot } from '../collection';
+-import { localizedId, localizedSlug, slugToLocaleData, slugToParam } from '../slugs';
+-import { validateLogoImports } from '../validateLogoImports';
+-import { BuiltInDefaultLocale } from '../i18n';
+-import type { Route, StarlightDocsCollectionEntry, StarlightDocsEntry } from './types';
++import type { GetStaticPathsItem } from "astro";
++import { getCollection } from "astro:content";
++import config from "virtual:starlight/user-config";
++import project from "virtual:starlight/project-context";
++import { getCollectionPathFromRoot } from "../collection";
++import {
++  localizedId,
++  localizedSlug,
++  slugToLocaleData,
++  slugToParam,
++} from "../slugs";
++import { validateLogoImports } from "../validateLogoImports";
++import { BuiltInDefaultLocale } from "../i18n";
++import type {
++  Route,
++  StarlightDocsCollectionEntry,
++  StarlightDocsEntry,
++} from "./types";
+ 
+ // Validate any user-provided logos imported correctly.
+ // We do this here so all pages trigger it and at the top level so it runs just once.
+ validateLogoImports();
+ 
+ interface Path extends GetStaticPathsItem {
+-	params: { slug: string | undefined };
+-	props: Route;
++  params: { slug: string | undefined };
++  props: Route;
+ }
+ 
+ /**
+@@ -22,92 +31,110 @@ interface Path extends GetStaticPathsItem {
+  * `index` is stripped, but in the root of a collection, we get a slug of `index`.
+  * We map that to an empty string for consistent behaviour.
+  */
+-const normalizeIndexSlug = (slug: string) => (slug === 'index' ? '' : slug);
++const normalizeIndexSlug = (slug: string) => (slug === "index" ? "" : slug);
+ 
+ /** Normalize the different collection entry we can get from a legacy collection or a loader. */
+-export function normalizeCollectionEntry(entry: StarlightDocsCollectionEntry): StarlightDocsEntry {
+-	const slug = normalizeIndexSlug(entry.slug ?? entry.id);
+-	return {
+-		...entry,
+-		// In a collection with a loader, the `id` is a slug and should be normalized.
+-		id: entry.slug ? entry.id : slug,
+-		// In a legacy collection, the `filePath` property doesn't exist.
+-		filePath: entry.filePath ?? `${getCollectionPathFromRoot('docs', project)}/${entry.id}`,
+-		// In a collection with a loader, the `slug` property is replaced by the `id`.
+-		slug: normalizeIndexSlug(entry.slug ?? entry.id),
+-	};
++export function normalizeCollectionEntry(
++  entry: StarlightDocsCollectionEntry
++): StarlightDocsEntry {
++  const slug = normalizeIndexSlug(entry.slug ?? entry.id);
++  return {
++    ...entry,
++    // In a collection with a loader, the `id` is a slug and should be normalized.
++    id: entry.slug ? entry.id : slug,
++    // In a legacy collection, the `filePath` property doesn't exist.
++    filePath:
++      entry.filePath ??
++      `${getCollectionPathFromRoot("docs", project)}/${entry.id}`,
++    // In a collection with a loader, the `slug` property is replaced by the `id`.
++    slug: normalizeIndexSlug(entry.slug ?? entry.id),
++  };
+ }
+ 
+ /** All entries in the docs content collection. */
+ const docs: StarlightDocsEntry[] = (
+-	(await getCollection('docs', ({ data }) => {
+-		// In production, filter out drafts.
+-		return import.meta.env.MODE !== 'production' || data.draft === false;
+-	})) ?? []
++  (await getCollection("docs", ({ data }) => {
++    // In production, filter out drafts.
++    return import.meta.env.MODE !== "production" || data.draft === false;
++  })) ?? []
+ ).map(normalizeCollectionEntry);
+ 
++function cleanSegment(path: string): string {
++  let segments = path.split("/");
++  if (segments[0] === segments[2]) {
++    segments.splice(2, 1); // Remove the third segment (index 2)
++  }
++  return segments.join("/"); // Join the segments back into a string
++}
++
+ function getRoutes(): Route[] {
+-	const routes: Route[] = docs.map((entry) => ({
+-		entry,
+-		slug: entry.slug,
+-		id: entry.id,
+-		entryMeta: slugToLocaleData(entry.slug),
+-		...slugToLocaleData(entry.slug),
+-	}));
++  const routes: Route[] = docs.map((entry) => ({
++    entry: {...entry, id: cleanSegment(entry.id), slug: cleanSegment(entry.slug)},
++    slug: cleanSegment(entry.slug),
++    id: cleanSegment(entry.id),
++    entryMeta: slugToLocaleData(cleanSegment(entry.slug)),
++    ...slugToLocaleData(cleanSegment(entry.slug)),
++  }));
+ 
+-	// In multilingual sites, add required fallback routes.
+-	if (config.isMultilingual) {
+-		/** Entries in the docs content collection for the default locale. */
+-		const defaultLocaleDocs = getLocaleDocs(
+-			config.defaultLocale?.locale === 'root' ? undefined : config.defaultLocale?.locale
+-		);
+-		for (const key in config.locales) {
+-			if (key === config.defaultLocale.locale) continue;
+-			const localeConfig = config.locales[key];
+-			if (!localeConfig) continue;
+-			const locale = key === 'root' ? undefined : key;
+-			const localeDocs = getLocaleDocs(locale);
+-			for (const fallback of defaultLocaleDocs) {
+-				const slug = localizedSlug(fallback.slug, locale);
+-				const id = project.legacyCollections ? localizedId(fallback.id, locale) : slug;
+-				const doesNotNeedFallback = localeDocs.some((doc) => doc.slug === slug);
+-				if (doesNotNeedFallback) continue;
+-				routes.push({
+-					entry: fallback,
+-					slug,
+-					id,
+-					isFallback: true,
+-					lang: localeConfig.lang || BuiltInDefaultLocale.lang,
+-					locale,
+-					dir: localeConfig.dir,
+-					entryMeta: slugToLocaleData(fallback.slug),
+-				});
+-			}
+-		}
+-	}
++  // In multilingual sites, add required fallback routes.
++  if (config.isMultilingual) {
++    /** Entries in the docs content collection for the default locale. */
++    const defaultLocaleDocs = getLocaleDocs(
++      config.defaultLocale?.locale === "root"
++        ? undefined
++        : config.defaultLocale?.locale
++    );
++    for (const key in config.locales) {
++      if (key === config.defaultLocale.locale) continue;
++      const localeConfig = config.locales[key];
++      if (!localeConfig) continue;
++      const locale = key === "root" ? undefined : key;
++      const localeDocs = getLocaleDocs(locale);
++      for (const fallback of defaultLocaleDocs) {
++        const slug = localizedSlug(fallback.slug, locale);
++        const id = project.legacyCollections
++          ? localizedId(fallback.id, locale)
++          : slug;
++        const doesNotNeedFallback = localeDocs.some((doc) => doc.slug === slug);
++        if (doesNotNeedFallback) continue;
++        routes.push({
++          entry: fallback,
++          slug,
++          id,
++          isFallback: true,
++          lang: localeConfig.lang || BuiltInDefaultLocale.lang,
++          locale,
++          dir: localeConfig.dir,
++          entryMeta: slugToLocaleData(fallback.slug),
++        });
++      }
++    }
++  }
+ 
+-	return routes;
++  return routes;
+ }
+ export const routes = getRoutes();
+ 
+ function getParamRouteMapping(): ReadonlyMap<string | undefined, Route> {
+-	const map = new Map<string | undefined, Route>();
+-	for (const route of routes) {
+-		map.set(slugToParam(route.slug), route);
+-	}
+-	return map;
++  const map = new Map<string | undefined, Route>();
++  for (const route of routes) {
++    map.set(slugToParam(route.slug), route);
++  }
++  return map;
+ }
+ const routesBySlugParam = getParamRouteMapping();
+ 
+-export function getRouteBySlugParam(slugParam: string | undefined): Route | undefined {
+-	return routesBySlugParam.get(slugParam?.replace(/\/$/, '') || undefined);
++export function getRouteBySlugParam(
++  slugParam: string | undefined
++): Route | undefined {
++  return routesBySlugParam.get(slugParam?.replace(/\/$/, "") || undefined);
+ }
+ 
+ function getPaths(): Path[] {
+-	return routes.map((route) => ({
+-		params: { slug: slugToParam(route.slug) },
+-		props: route,
+-	}));
++  return routes.map((route) => ({
++    params: { slug: slugToParam(route.slug) },
++    props: route,
++  }));
+ }
+ export const paths = getPaths();
+ 
+@@ -116,7 +143,7 @@ export const paths = getPaths();
+  * A locale of `undefined` is treated as the “root” locale, if configured.
+  */
+ export function getLocaleRoutes(locale: string | undefined): Route[] {
+-	return filterByLocale(routes, locale);
++  return filterByLocale(routes, locale);
+ }
+ 
+ /**
+@@ -124,20 +151,27 @@ export function getLocaleRoutes(locale: string | undefined): Route[] {
+  * A locale of `undefined` is treated as the “root” locale, if configured.
+  */
+ function getLocaleDocs(locale: string | undefined): StarlightDocsEntry[] {
+-	return filterByLocale(docs, locale);
++  return filterByLocale(docs, locale);
+ }
+ 
+ /** Filter an array to find items whose slug matches the passed locale. */
+-function filterByLocale<T extends { slug: string }>(items: T[], locale: string | undefined): T[] {
+-	if (config.locales) {
+-		if (locale && locale in config.locales) {
+-			return items.filter((i) => i.slug === locale || i.slug.startsWith(locale + '/'));
+-		} else if (config.locales.root) {
+-			const langKeys = Object.keys(config.locales).filter((k) => k !== 'root');
+-			const isLangIndex = new RegExp(`^(${langKeys.join('|')})$`);
+-			const isLangDir = new RegExp(`^(${langKeys.join('|')})/`);
+-			return items.filter((i) => !isLangIndex.test(i.slug) && !isLangDir.test(i.slug));
+-		}
+-	}
+-	return items;
++function filterByLocale<T extends { slug: string }>(
++  items: T[],
++  locale: string | undefined
++): T[] {
++  if (config.locales) {
++    if (locale && locale in config.locales) {
++      return items.filter(
++        (i) => i.slug === locale || i.slug.startsWith(locale + "/")
++      );
++    } else if (config.locales.root) {
++      const langKeys = Object.keys(config.locales).filter((k) => k !== "root");
++      const isLangIndex = new RegExp(`^(${langKeys.join("|")})$`);
++      const isLangDir = new RegExp(`^(${langKeys.join("|")})/`);
++      return items.filter(
++        (i) => !isLangIndex.test(i.slug) && !isLangDir.test(i.slug)
++      );
++    }
++  }
++  return items;
+ }
diff --git a/utils/createPathFormatter.ts b/utils/createPathFormatter.ts
index 52c9527c6d8c6756125c2f746cf14d055ed1e3ef..7f406bf862ad75374da9bd9111e7c44accbaf4db 100644
--- a/utils/createPathFormatter.ts
+++ b/utils/createPathFormatter.ts
@@ -1,60 +1,66 @@
-import type { AstroConfig } from 'astro';
-import { fileWithBase, pathWithBase } from './base';
+import type { AstroConfig } from "astro";
+import { fileWithBase, pathWithBase } from "./base";
 import {
-	ensureHtmlExtension,
-	ensureTrailingSlash,
-	stripHtmlExtension,
-	stripTrailingSlash,
-} from './path';
+  ensureHtmlExtension,
+  ensureTrailingSlash,
+  stripHtmlExtension,
+  stripTrailingSlash,
+} from "./path";
 
 interface FormatPathOptions {
-	format?: AstroConfig['build']['format'];
-	trailingSlash?: AstroConfig['trailingSlash'];
+  format?: AstroConfig["build"]["format"];
+  trailingSlash?: AstroConfig["trailingSlash"];
 }
 
 const defaultFormatStrategy = {
-	addBase: pathWithBase,
-	handleExtension: (href: string) => stripHtmlExtension(href),
+  addBase: pathWithBase,
+  handleExtension: (href: string) => stripHtmlExtension(href),
 };
 
 const formatStrategies = {
-	file: {
-		addBase: fileWithBase,
-		handleExtension: (href: string) => ensureHtmlExtension(href),
-	},
-	directory: defaultFormatStrategy,
-	preserve: defaultFormatStrategy,
+  file: {
+    addBase: fileWithBase,
+    handleExtension: (href: string) => ensureHtmlExtension(href),
+  },
+  directory: defaultFormatStrategy,
+  preserve: defaultFormatStrategy,
 };
 
 const trailingSlashStrategies = {
-	always: ensureTrailingSlash,
-	never: stripTrailingSlash,
-	ignore: (href: string) => href,
+  always: ensureTrailingSlash,
+  never: stripTrailingSlash,
+  ignore: (href: string) => href,
 };
 
 /** Format a path based on the project config. */
 function formatPath(
-	href: string,
-	{ format = 'directory', trailingSlash = 'ignore' }: FormatPathOptions
+  href: string,
+  { format = "directory", trailingSlash = "ignore" }: FormatPathOptions
 ) {
-	const formatStrategy = formatStrategies[format];
-	const trailingSlashStrategy = trailingSlashStrategies[trailingSlash];
+  const segments = href.split("/");
+  const formatStrategy = formatStrategies[format];
+  const trailingSlashStrategy = trailingSlashStrategies[trailingSlash];
 
-	// Handle extension
-	href = formatStrategy.handleExtension(href);
+  if (segments[1] === segments[3]) {
+    segments.splice(3, 1);
+    href = segments.join("/");
+  }
 
-	// Add base
-	href = formatStrategy.addBase(href);
+  // Handle extension
+  href = formatStrategy.handleExtension(href);
 
-	// Skip trailing slash handling for `build.format: 'file'`
-	if (format === 'file') return href;
+  // Add base
+  href = formatStrategy.addBase(href);
 
-	// Handle trailing slash
-	href = href === '/' ? href : trailingSlashStrategy(href);
+  // Skip trailing slash handling for `build.format: 'file'`
+  if (format === "file") return href;
 
-	return href;
+  // Handle trailing slash
+  href = href === "/" ? href : trailingSlashStrategy(href);
+
+  return href;
 }
 
 export function createPathFormatter(opts: FormatPathOptions) {
-	return (href: string) => formatPath(href, opts);
+  return (href: string) => formatPath(href, opts);
 }
diff --git a/utils/navigation.ts b/utils/navigation.ts
index cfcd2e837d328fb0f15c7706862f115a184e2ff3..c86d73da756e567c2f1c9bef235157f50dd41927 100644
--- a/utils/navigation.ts
+++ b/utils/navigation.ts
@@ -1,42 +1,42 @@
-import { AstroError } from 'astro/errors';
-import project from 'virtual:starlight/project-context';
-import config from 'virtual:starlight/user-config';
-import type { Badge, I18nBadge, I18nBadgeConfig } from '../schemas/badge';
-import type { PrevNextLinkConfig } from '../schemas/prevNextLink';
+import { AstroError } from "astro/errors";
+import project from "virtual:starlight/project-context";
+import config from "virtual:starlight/user-config";
+import type { Badge, I18nBadge, I18nBadgeConfig } from "../schemas/badge";
+import type { PrevNextLinkConfig } from "../schemas/prevNextLink";
 import type {
-	AutoSidebarGroup,
-	InternalSidebarLinkItem,
-	LinkHTMLAttributes,
-	SidebarItem,
-	SidebarLinkItem,
-} from '../schemas/sidebar';
-import { getCollectionPathFromRoot } from './collection';
-import { createPathFormatter } from './createPathFormatter';
-import { formatPath } from './format-path';
-import { BuiltInDefaultLocale, pickLang } from './i18n';
+  AutoSidebarGroup,
+  InternalSidebarLinkItem,
+  LinkHTMLAttributes,
+  SidebarItem,
+  SidebarLinkItem,
+} from "../schemas/sidebar";
+import { getCollectionPathFromRoot } from "./collection";
+import { createPathFormatter } from "./createPathFormatter";
+import { formatPath } from "./format-path";
+import { BuiltInDefaultLocale, pickLang } from "./i18n";
 import {
-	ensureLeadingSlash,
-	ensureTrailingSlash,
-	stripExtension,
-	stripLeadingAndTrailingSlashes,
-} from './path';
-import { getLocaleRoutes, routes } from './routing';
+  ensureLeadingSlash,
+  ensureTrailingSlash,
+  stripExtension,
+  stripLeadingAndTrailingSlashes,
+} from "./path";
+import { getLocaleRoutes, routes } from "./routing";
 import type {
-	SidebarGroup,
-	SidebarLink,
-	PaginationLinks,
-	Route,
-	SidebarEntry,
-} from './routing/types';
-import { localeToLang, localizedId, slugToPathname } from './slugs';
-import type { StarlightConfig } from './user-config';
+  SidebarGroup,
+  SidebarLink,
+  PaginationLinks,
+  Route,
+  SidebarEntry,
+} from "./routing/types";
+import { localeToLang, localizedId, slugToPathname } from "./slugs";
+import type { StarlightConfig } from "./user-config";
 
-const DirKey = Symbol('DirKey');
-const SlugKey = Symbol('SlugKey');
+const DirKey = Symbol("DirKey");
+const SlugKey = Symbol("SlugKey");
 
-const neverPathFormatter = createPathFormatter({ trailingSlash: 'never' });
+const neverPathFormatter = createPathFormatter({ trailingSlash: "never" });
 
-const docsCollectionPathFromRoot = getCollectionPathFromRoot('docs', project);
+const docsCollectionPathFromRoot = getCollectionPathFromRoot("docs", project);
 
 /**
  * A representation of the route structure. For each object entry:
@@ -45,77 +45,77 @@ const docsCollectionPathFromRoot = getCollectionPathFromRoot('docs', project);
  * is the full entry.
  */
 interface Dir {
-	[DirKey]: undefined;
-	[SlugKey]: string;
-	[item: string]: Dir | Route;
+  [DirKey]: undefined;
+  [SlugKey]: string;
+  [item: string]: Dir | Route;
 }
 
 /** Create a new directory object. */
 function makeDir(slug: string): Dir {
-	const dir = {} as Dir;
-	// Add DirKey and SlugKey as non-enumerable properties so that `Object.entries(dir)` ignores them.
-	Object.defineProperty(dir, DirKey, { enumerable: false });
-	Object.defineProperty(dir, SlugKey, { value: slug, enumerable: false });
-	return dir;
+  const dir = {} as Dir;
+  // Add DirKey and SlugKey as non-enumerable properties so that `Object.entries(dir)` ignores them.
+  Object.defineProperty(dir, DirKey, { enumerable: false });
+  Object.defineProperty(dir, SlugKey, { value: slug, enumerable: false });
+  return dir;
 }
 
 /** Test if the passed object is a directory record.  */
 function isDir(data: Record<string, unknown>): data is Dir {
-	return DirKey in data;
+  return DirKey in data;
 }
 
 /** Convert an item in a user’s sidebar config to a sidebar entry. */
 function configItemToEntry(
-	item: SidebarItem,
-	currentPathname: string,
-	locale: string | undefined,
-	routes: Route[]
+  item: SidebarItem,
+  currentPathname: string,
+  locale: string | undefined,
+  routes: Route[]
 ): SidebarEntry {
-	if ('link' in item) {
-		return linkFromSidebarLinkItem(item, locale);
-	} else if ('autogenerate' in item) {
-		return groupFromAutogenerateConfig(item, locale, routes, currentPathname);
-	} else if ('slug' in item) {
-		return linkFromInternalSidebarLinkItem(item, locale);
-	} else {
-		const label = pickLang(item.translations, localeToLang(locale)) || item.label;
-		return {
-			type: 'group',
-			label,
-			entries: item.items.map((i) => configItemToEntry(i, currentPathname, locale, routes)),
-			collapsed: item.collapsed,
-			badge: getSidebarBadge(item.badge, locale, label),
-		};
-	}
+  if ("link" in item) {
+    return linkFromSidebarLinkItem(item, locale);
+  } else if ("autogenerate" in item) {
+    return groupFromAutogenerateConfig(item, locale, routes, currentPathname);
+  } else if ("slug" in item) {
+    return linkFromInternalSidebarLinkItem(item, locale);
+  } else {
+    const label = pickLang(item.translations, localeToLang(locale)) || item.label;
+    return {
+      type: "group",
+      label,
+      entries: item.items.map((i) => configItemToEntry(i, currentPathname, locale, routes)),
+      collapsed: item.collapsed,
+      badge: getSidebarBadge(item.badge, locale, label),
+    };
+  }
 }
 
 /** Autogenerate a group of links from a user’s sidebar config. */
 function groupFromAutogenerateConfig(
-	item: AutoSidebarGroup,
-	locale: string | undefined,
-	routes: Route[],
-	currentPathname: string
+  item: AutoSidebarGroup,
+  locale: string | undefined,
+  routes: Route[],
+  currentPathname: string
 ): SidebarGroup {
-	const { collapsed: subgroupCollapsed, directory } = item.autogenerate;
-	const localeDir = locale ? locale + '/' + directory : directory;
-	const dirDocs = routes.filter((doc) => {
-		const filePathFromContentDir = getRoutePathRelativeToCollectionRoot(doc, locale);
-		return (
-			// Match against `foo.md` or `foo/index.md`.
-			stripExtension(filePathFromContentDir) === localeDir ||
-			// Match against `foo/anything/else.md`.
-			filePathFromContentDir.startsWith(localeDir + '/')
-		);
-	});
-	const tree = treeify(dirDocs, locale, localeDir);
-	const label = pickLang(item.translations, localeToLang(locale)) || item.label;
-	return {
-		type: 'group',
-		label,
-		entries: sidebarFromDir(tree, currentPathname, locale, subgroupCollapsed ?? item.collapsed),
-		collapsed: item.collapsed,
-		badge: getSidebarBadge(item.badge, locale, label),
-	};
+  const { collapsed: subgroupCollapsed, directory } = item.autogenerate;
+  const localeDir = locale ? locale + "/" + directory : directory;
+  const dirDocs = routes.filter((doc) => {
+    const filePathFromContentDir = getRoutePathRelativeToCollectionRoot(doc, locale);
+    return (
+      // Match against `foo.md` or `foo/index.md`.
+      stripExtension(filePathFromContentDir) === localeDir ||
+      // Match against `foo/anything/else.md`.
+      filePathFromContentDir.startsWith(localeDir + "/")
+    );
+  });
+  const tree = treeify(dirDocs, locale, localeDir);
+  const label = pickLang(item.translations, localeToLang(locale)) || item.label;
+  return {
+    type: "group",
+    label,
+    entries: sidebarFromDir(tree, currentPathname, locale, subgroupCollapsed ?? item.collapsed),
+    collapsed: item.collapsed,
+    badge: getSidebarBadge(item.badge, locale, label),
+  };
 }
 
 /** Check if a string starts with one of `http://` or `https://`. */
@@ -123,153 +123,177 @@ const isAbsolute = (link: string) => /^https?:\/\//.test(link);
 
 /** Create a link entry from a manual link item in user config. */
 function linkFromSidebarLinkItem(item: SidebarLinkItem, locale: string | undefined) {
-	let href = item.link;
-	if (!isAbsolute(href)) {
-		href = ensureLeadingSlash(href);
-		// Inject current locale into link.
-		if (locale) href = '/' + locale + href;
-	}
-	const label = pickLang(item.translations, localeToLang(locale)) || item.label;
-	return makeSidebarLink(href, label, getSidebarBadge(item.badge, locale, label), item.attrs);
+  let href = item.link;
+  if (!isAbsolute(href)) {
+    href = ensureLeadingSlash(href);
+    // Inject current locale into link.
+    if (locale) href = "/" + locale + href;
+  }
+  const label = pickLang(item.translations, localeToLang(locale)) || item.label;
+  return makeSidebarLink(href, label, getSidebarBadge(item.badge, locale, label), item.attrs);
 }
 
 /** Create a link entry from an automatic internal link item in user config. */
 function linkFromInternalSidebarLinkItem(
-	item: InternalSidebarLinkItem,
-	locale: string | undefined
+  item: InternalSidebarLinkItem,
+  locale: string | undefined
 ) {
-	// Astro passes root `index.[md|mdx]` entries with a slug of `index`
-	const slug = item.slug === 'index' ? '' : item.slug;
-	const localizedSlug = locale ? (slug ? locale + '/' + slug : locale) : slug;
-	const route = routes.find((entry) => localizedSlug === entry.slug);
-	if (!route) {
-		const hasExternalSlashes = item.slug.at(0) === '/' || item.slug.at(-1) === '/';
-		if (hasExternalSlashes) {
-			throw new AstroError(
-				`The slug \`"${item.slug}"\` specified in the Starlight sidebar config must not start or end with a slash.`,
-				`Please try updating \`"${item.slug}"\` to \`"${stripLeadingAndTrailingSlashes(item.slug)}"\`.`
-			);
-		} else {
-			throw new AstroError(
-				`The slug \`"${item.slug}"\` specified in the Starlight sidebar config does not exist.`,
-				'Update the Starlight config to reference a valid entry slug in the docs content collection.\n' +
-					'Learn more about Astro content collection slugs at https://docs.astro.build/en/reference/modules/astro-content/#getentry'
-			);
-		}
-	}
-	const frontmatter = route.entry.data;
-	const label =
-		pickLang(item.translations, localeToLang(locale)) ||
-		item.label ||
-		frontmatter.sidebar?.label ||
-		frontmatter.title;
-	const badge = item.badge ?? frontmatter.sidebar?.badge;
-	const attrs = { ...frontmatter.sidebar?.attrs, ...item.attrs };
-	return makeSidebarLink(route.slug, label, getSidebarBadge(badge, locale, label), attrs);
+  // Astro passes root `index.[md|mdx]` entries with a slug of `index`
+  const slug = item.slug === "index" ? "" : item.slug;
+  const localizedSlug = locale ? (slug ? locale + "/" + slug : locale) : slug;
+  const route = routes.find((entry) => localizedSlug === entry.slug);
+  if (!route) {
+    const hasExternalSlashes = item.slug.at(0) === "/" || item.slug.at(-1) === "/";
+    if (hasExternalSlashes) {
+      throw new AstroError(
+        `The slug \`"${item.slug}"\` specified in the Starlight sidebar config must not start or end with a slash.`,
+        `Please try updating \`"${item.slug}"\` to \`"${stripLeadingAndTrailingSlashes(item.slug)}"\`.`
+      );
+    } else {
+      throw new AstroError(
+        `The slug \`"${item.slug}"\` specified in the Starlight sidebar config does not exist.`,
+        "Update the Starlight config to reference a valid entry slug in the docs content collection.\n" +
+          "Learn more about Astro content collection slugs at https://docs.astro.build/en/reference/modules/astro-content/#getentry"
+      );
+    }
+  }
+  const frontmatter = route.entry.data;
+  const label =
+    pickLang(item.translations, localeToLang(locale)) ||
+    item.label ||
+    frontmatter.sidebar?.label ||
+    frontmatter.title;
+  const badge = item.badge ?? frontmatter.sidebar?.badge;
+  const attrs = { ...frontmatter.sidebar?.attrs, ...item.attrs };
+  return makeSidebarLink(route.slug, label, getSidebarBadge(badge, locale, label), attrs);
 }
 
 /** Process sidebar link options to create a link entry. */
 function makeSidebarLink(
-	href: string,
-	label: string,
-	badge?: Badge,
-	attrs?: LinkHTMLAttributes
+  href: string,
+  label: string,
+  badge?: Badge,
+  attrs?: LinkHTMLAttributes
 ): SidebarLink {
-	if (!isAbsolute(href)) {
-		href = formatPath(href);
-	}
-	return makeLink({ label, href, badge, attrs });
+  if (!isAbsolute(href)) {
+    href = formatPath(href);
+  }
+  return makeLink({ label, href, badge, attrs });
 }
 
 /** Create a link entry */
 function makeLink({
-	attrs = {},
-	badge = undefined,
-	...opts
+  attrs = {},
+  badge = undefined,
+  ...opts
 }: {
-	label: string;
-	href: string;
-	badge?: Badge | undefined;
-	attrs?: LinkHTMLAttributes | undefined;
+  label: string;
+  href: string;
+  badge?: Badge | undefined;
+  attrs?: LinkHTMLAttributes | undefined;
 }): SidebarLink {
-	return { type: 'link', ...opts, badge, isCurrent: false, attrs };
+  return { type: "link", ...opts, badge, isCurrent: false, attrs };
 }
 
 /** Test if two paths are equivalent even if formatted differently. */
 function pathsMatch(pathA: string, pathB: string) {
-	return neverPathFormatter(pathA) === neverPathFormatter(pathB);
+  return neverPathFormatter(pathA) === neverPathFormatter(pathB);
 }
 
 /** Get the segments leading to a page. */
 function getBreadcrumbs(path: string, baseDir: string): string[] {
-	// Strip extension from path.
-	const pathWithoutExt = stripExtension(path);
-	// Index paths will match `baseDir` and don’t include breadcrumbs.
-	if (pathWithoutExt === baseDir) return [];
-	// Ensure base directory ends in a trailing slash.
-	baseDir = ensureTrailingSlash(baseDir);
-	// Strip base directory from path if present.
-	const relativePath = pathWithoutExt.startsWith(baseDir)
-		? pathWithoutExt.replace(baseDir, '')
-		: pathWithoutExt;
-
-	return relativePath.split('/');
+  // Strip extension from path.
+  const pathWithoutExt = stripExtension(path);
+  // Index paths will match `baseDir` and don’t include breadcrumbs.
+  if (pathWithoutExt === baseDir) return [];
+  // Ensure base directory ends in a trailing slash.
+  baseDir = ensureTrailingSlash(baseDir);
+  // Strip base directory from path if present.
+  const relativePath = pathWithoutExt.startsWith(baseDir)
+    ? pathWithoutExt.replace(baseDir, "")
+    : pathWithoutExt;
+
+  return relativePath.split("/");
 }
 
 /** Return the path of a route relative to the root of the collection, which is equivalent to legacy IDs. */
 function getRoutePathRelativeToCollectionRoot(route: Route, locale: string | undefined) {
-	return project.legacyCollections
-		? route.id
-		: // For collections with a loader, use a localized filePath relative to the collection
-			localizedId(route.entry.filePath.replace(`${docsCollectionPathFromRoot}/`, ''), locale);
+  return project.legacyCollections
+    ? route.id
+    : // For collections with a loader, use a localized filePath relative to the collection
+      localizedId(route.entry.filePath.replace(`${docsCollectionPathFromRoot}/`, ""), locale);
+}
+
+function cleanSegment(path: string): string {
+  let segments = path.split("/");
+  if (segments[0] === segments[2]) {
+    segments.splice(2, 1); // Remove the third segment (index 2)
+  }
+  return segments.join("/"); // Join the segments back into a string
 }
 
 /** Turn a flat array of routes into a tree structure. */
 function treeify(routes: Route[], locale: string | undefined, baseDir: string): Dir {
-	const treeRoot: Dir = makeDir(baseDir);
-	routes
-		// Remove any entries that should be hidden
-		.filter((doc) => !doc.entry.data.sidebar.hidden)
-		// Compute the path of each entry from the root of the collection ahead of time.
-		.map((doc) => [getRoutePathRelativeToCollectionRoot(doc, locale), doc] as const)
-		// Sort by depth, to build the tree depth first.
-		.sort(([a], [b]) => b.split('/').length - a.split('/').length)
-		// Build the tree
-		.forEach(([filePathFromContentDir, doc]) => {
-			const parts = getBreadcrumbs(filePathFromContentDir, baseDir);
-			let currentNode = treeRoot;
-
-			parts.forEach((part, index) => {
-				const isLeaf = index === parts.length - 1;
-
-				// Handle directory index pages by renaming them to `index`
-				if (isLeaf && currentNode.hasOwnProperty(part)) {
-					currentNode = currentNode[part] as Dir;
-					part = 'index';
-				}
-
-				// Recurse down the tree if this isn’t the leaf node.
-				if (!isLeaf) {
-					const path = currentNode[SlugKey];
-					currentNode[part] ||= makeDir(stripLeadingAndTrailingSlashes(path + '/' + part));
-					currentNode = currentNode[part] as Dir;
-				} else {
-					currentNode[part] = doc;
-				}
-			});
-		});
-
-	return treeRoot;
+  const treeRoot: Dir = makeDir(baseDir);
+  const testRoutes = routes.map((item) => {
+    let newItem = { ...item, entry: { ...item.entry } };
+
+    if (newItem.id) newItem.id = cleanSegment(newItem.id);
+    if (newItem.slug) newItem.slug = cleanSegment(newItem.slug);
+
+    // Also handle id and slug inside entry if it exists
+    if (newItem.entry) {
+      newItem.entry = { ...newItem.entry };
+      newItem.entry.id = cleanSegment(newItem.entry.id);
+      newItem.entry.slug = cleanSegment(newItem.entry.slug);
+    }
+
+    return newItem;
+  });
+
+  testRoutes
+    // Remove any entries that should be hidden
+    .filter((doc) => !doc.entry.data.sidebar.hidden)
+    // Compute the path of each entry from the root of the collection ahead of time.
+    .map((doc) => [getRoutePathRelativeToCollectionRoot(doc, locale), doc] as const)
+    // Sort by depth, to build the tree depth first.
+    .sort(([a], [b]) => b.split("/").length - a.split("/").length)
+    // Build the tree
+    .forEach(([filePathFromContentDir, doc]) => {
+      const parts = getBreadcrumbs(filePathFromContentDir, baseDir);
+      let currentNode = treeRoot;
+
+      parts.forEach((part, index) => {
+        const isLeaf = index === parts.length - 1;
+
+        // Handle directory index pages by renaming them to `index`
+        if (isLeaf && currentNode.hasOwnProperty(part)) {
+          currentNode = currentNode[part] as Dir;
+          part = "index";
+        }
+
+        // Recurse down the tree if this isn’t the leaf node.
+        if (!isLeaf) {
+          const path = currentNode[SlugKey];
+          currentNode[part] ||= makeDir(stripLeadingAndTrailingSlashes(path + "/" + part));
+          currentNode = currentNode[part] as Dir;
+        } else {
+          currentNode[part] = doc;
+        }
+      });
+    });
+
+  return treeRoot;
 }
 
 /** Create a link entry for a given content collection entry. */
 function linkFromRoute(route: Route): SidebarLink {
-	return makeSidebarLink(
-		slugToPathname(route.slug),
-		route.entry.data.sidebar.label || route.entry.data.title,
-		route.entry.data.sidebar.badge,
-		route.entry.data.sidebar.attrs
-	);
+  return makeSidebarLink(
+    slugToPathname(route.slug),
+    route.entry.data.sidebar.label || route.entry.data.title,
+    route.entry.data.sidebar.badge,
+    route.entry.data.sidebar.attrs
+  );
 }
 
 /**
@@ -277,69 +301,69 @@ function linkFromRoute(route: Route): SidebarLink {
  * Directories have the weight of the lowest weighted route they contain.
  */
 function getOrder(routeOrDir: Route | Dir): number {
-	return isDir(routeOrDir)
-		? Math.min(...Object.values(routeOrDir).flatMap(getOrder))
-		: // If no order value is found, set it to the largest number possible.
-			(routeOrDir.entry.data.sidebar.order ?? Number.MAX_VALUE);
+  return isDir(routeOrDir)
+    ? Math.min(...Object.values(routeOrDir).flatMap(getOrder))
+    : // If no order value is found, set it to the largest number possible.
+      (routeOrDir.entry.data.sidebar.order ?? Number.MAX_VALUE);
 }
 
 /** Sort a directory’s entries by user-specified order or alphabetically if no order specified. */
 function sortDirEntries(dir: [string, Dir | Route][]): [string, Dir | Route][] {
-	const collator = new Intl.Collator(localeToLang(undefined));
-	return dir.sort(([_keyA, a], [_keyB, b]) => {
-		const [aOrder, bOrder] = [getOrder(a), getOrder(b)];
-		// Pages are sorted by order in ascending order.
-		if (aOrder !== bOrder) return aOrder < bOrder ? -1 : 1;
-		// If two pages have the same order value they will be sorted by their slug.
-		return collator.compare(isDir(a) ? a[SlugKey] : a.slug, isDir(b) ? b[SlugKey] : b.slug);
-	});
+  const collator = new Intl.Collator(localeToLang(undefined));
+  return dir.sort(([_keyA, a], [_keyB, b]) => {
+    const [aOrder, bOrder] = [getOrder(a), getOrder(b)];
+    // Pages are sorted by order in ascending order.
+    if (aOrder !== bOrder) return aOrder < bOrder ? -1 : 1;
+    // If two pages have the same order value they will be sorted by their slug.
+    return collator.compare(isDir(a) ? a[SlugKey] : a.slug, isDir(b) ? b[SlugKey] : b.slug);
+  });
 }
 
 /** Create a group entry for a given content collection directory. */
 function groupFromDir(
-	dir: Dir,
-	fullPath: string,
-	dirName: string,
-	currentPathname: string,
-	locale: string | undefined,
-	collapsed: boolean
+  dir: Dir,
+  fullPath: string,
+  dirName: string,
+  currentPathname: string,
+  locale: string | undefined,
+  collapsed: boolean
 ): SidebarGroup {
-	const entries = sortDirEntries(Object.entries(dir)).map(([key, dirOrRoute]) =>
-		dirToItem(dirOrRoute, `${fullPath}/${key}`, key, currentPathname, locale, collapsed)
-	);
-	return {
-		type: 'group',
-		label: dirName,
-		entries,
-		collapsed,
-		badge: undefined,
-	};
+  const entries = sortDirEntries(Object.entries(dir)).map(([key, dirOrRoute]) =>
+    dirToItem(dirOrRoute, `${fullPath}/${key}`, key, currentPathname, locale, collapsed)
+  );
+  return {
+    type: "group",
+    label: dirName,
+    entries,
+    collapsed,
+    badge: undefined,
+  };
 }
 
 /** Create a sidebar entry for a directory or content entry. */
 function dirToItem(
-	dirOrRoute: Dir[string],
-	fullPath: string,
-	dirName: string,
-	currentPathname: string,
-	locale: string | undefined,
-	collapsed: boolean
+  dirOrRoute: Dir[string],
+  fullPath: string,
+  dirName: string,
+  currentPathname: string,
+  locale: string | undefined,
+  collapsed: boolean
 ): SidebarEntry {
-	return isDir(dirOrRoute)
-		? groupFromDir(dirOrRoute, fullPath, dirName, currentPathname, locale, collapsed)
-		: linkFromRoute(dirOrRoute);
+  return isDir(dirOrRoute)
+    ? groupFromDir(dirOrRoute, fullPath, dirName, currentPathname, locale, collapsed)
+    : linkFromRoute(dirOrRoute);
 }
 
 /** Create a sidebar entry for a given content directory. */
 function sidebarFromDir(
-	tree: Dir,
-	currentPathname: string,
-	locale: string | undefined,
-	collapsed: boolean
+  tree: Dir,
+  currentPathname: string,
+  locale: string | undefined,
+  collapsed: boolean
 ) {
-	return sortDirEntries(Object.entries(tree)).map(([key, dirOrRoute]) =>
-		dirToItem(dirOrRoute, key, key, currentPathname, locale, collapsed)
-	);
+  return sortDirEntries(Object.entries(tree)).map(([key, dirOrRoute]) =>
+    dirToItem(dirOrRoute, key, key, currentPathname, locale, collapsed)
+  );
 }
 
 /**
@@ -355,180 +379,180 @@ const intermediateSidebars = new Map<string | undefined, SidebarEntry[]>();
 
 /** Get the sidebar for the current page using the global config. */
 export function getSidebar(pathname: string, locale: string | undefined): SidebarEntry[] {
-	let intermediateSidebar = intermediateSidebars.get(locale);
-	if (!intermediateSidebar) {
-		intermediateSidebar = getIntermediateSidebarFromConfig(config.sidebar, pathname, locale);
-		intermediateSidebars.set(locale, intermediateSidebar);
-	}
-	return getSidebarFromIntermediateSidebar(intermediateSidebar, pathname);
+  let intermediateSidebar = intermediateSidebars.get(locale);
+  if (!intermediateSidebar) {
+    intermediateSidebar = getIntermediateSidebarFromConfig(config.sidebar, pathname, locale);
+    intermediateSidebars.set(locale, intermediateSidebar);
+  }
+  return getSidebarFromIntermediateSidebar(intermediateSidebar, pathname);
 }
 
 /** Get the sidebar for the current page using the specified sidebar config. */
 export function getSidebarFromConfig(
-	sidebarConfig: StarlightConfig['sidebar'],
-	pathname: string,
-	locale: string | undefined
+  sidebarConfig: StarlightConfig["sidebar"],
+  pathname: string,
+  locale: string | undefined
 ): SidebarEntry[] {
-	const intermediateSidebar = getIntermediateSidebarFromConfig(sidebarConfig, pathname, locale);
-	return getSidebarFromIntermediateSidebar(intermediateSidebar, pathname);
+  const intermediateSidebar = getIntermediateSidebarFromConfig(sidebarConfig, pathname, locale);
+  return getSidebarFromIntermediateSidebar(intermediateSidebar, pathname);
 }
 
 /** Get the intermediate sidebar for the current page using the specified sidebar config. */
 function getIntermediateSidebarFromConfig(
-	sidebarConfig: StarlightConfig['sidebar'],
-	pathname: string,
-	locale: string | undefined
+  sidebarConfig: StarlightConfig["sidebar"],
+  pathname: string,
+  locale: string | undefined
 ): SidebarEntry[] {
-	const routes = getLocaleRoutes(locale);
-	if (sidebarConfig) {
-		return sidebarConfig.map((group) => configItemToEntry(group, pathname, locale, routes));
-	} else {
-		const tree = treeify(routes, locale, locale || '');
-		return sidebarFromDir(tree, pathname, locale, false);
-	}
+  const routes = getLocaleRoutes(locale);
+  if (sidebarConfig) {
+    return sidebarConfig.map((group) => configItemToEntry(group, pathname, locale, routes));
+  } else {
+    const tree = treeify(routes, locale, locale || "");
+    return sidebarFromDir(tree, pathname, locale, false);
+  }
 }
 
 /** Transform an intermediate sidebar into a sidebar for the current page. */
 function getSidebarFromIntermediateSidebar(
-	intermediateSidebar: SidebarEntry[],
-	pathname: string
+  intermediateSidebar: SidebarEntry[],
+  pathname: string
 ): SidebarEntry[] {
-	const sidebar = structuredClone(intermediateSidebar);
-	setIntermediateSidebarCurrentEntry(sidebar, pathname);
-	return sidebar;
+  const sidebar = structuredClone(intermediateSidebar);
+  setIntermediateSidebarCurrentEntry(sidebar, pathname);
+  return sidebar;
 }
 
 /** Marks the current page as such in an intermediate sidebar. */
 function setIntermediateSidebarCurrentEntry(
-	intermediateSidebar: SidebarEntry[],
-	pathname: string
+  intermediateSidebar: SidebarEntry[],
+  pathname: string
 ): boolean {
-	for (const entry of intermediateSidebar) {
-		if (entry.type === 'link' && pathsMatch(encodeURI(entry.href), pathname)) {
-			entry.isCurrent = true;
-			return true;
-		}
-
-		if (entry.type === 'group' && setIntermediateSidebarCurrentEntry(entry.entries, pathname)) {
-			return true;
-		}
-	}
-	return false;
+  for (const entry of intermediateSidebar) {
+    if (entry.type === "link" && pathsMatch(encodeURI(entry.href), pathname)) {
+      entry.isCurrent = true;
+      return true;
+    }
+
+    if (entry.type === "group" && setIntermediateSidebarCurrentEntry(entry.entries, pathname)) {
+      return true;
+    }
+  }
+  return false;
 }
 
 /** Generates a deterministic string based on the content of the passed sidebar. */
 export function getSidebarHash(sidebar: SidebarEntry[]): string {
-	let hash = 0;
-	const sidebarIdentity = recursivelyBuildSidebarIdentity(sidebar);
-	for (let i = 0; i < sidebarIdentity.length; i++) {
-		const char = sidebarIdentity.charCodeAt(i);
-		hash = (hash << 5) - hash + char;
-	}
-	return (hash >>> 0).toString(36).padStart(7, '0');
+  let hash = 0;
+  const sidebarIdentity = recursivelyBuildSidebarIdentity(sidebar);
+  for (let i = 0; i < sidebarIdentity.length; i++) {
+    const char = sidebarIdentity.charCodeAt(i);
+    hash = (hash << 5) - hash + char;
+  }
+  return (hash >>> 0).toString(36).padStart(7, "0");
 }
 
 /** Recurses through a sidebar tree to generate a string concatenating labels and link hrefs. */
 function recursivelyBuildSidebarIdentity(sidebar: SidebarEntry[]): string {
-	return sidebar
-		.flatMap((entry) =>
-			entry.type === 'group'
-				? entry.label + recursivelyBuildSidebarIdentity(entry.entries)
-				: entry.label + entry.href
-		)
-		.join('');
+  return sidebar
+    .flatMap((entry) =>
+      entry.type === "group"
+        ? entry.label + recursivelyBuildSidebarIdentity(entry.entries)
+        : entry.label + entry.href
+    )
+    .join("");
 }
 
 /** Turn the nested tree structure of a sidebar into a flat list of all the links. */
 export function flattenSidebar(sidebar: SidebarEntry[]): SidebarLink[] {
-	return sidebar.flatMap((entry) =>
-		entry.type === 'group' ? flattenSidebar(entry.entries) : entry
-	);
+  return sidebar.flatMap((entry) =>
+    entry.type === "group" ? flattenSidebar(entry.entries) : entry
+  );
 }
 
 /** Get previous/next pages in the sidebar or the ones from the frontmatter if any. */
 export function getPrevNextLinks(
-	sidebar: SidebarEntry[],
-	paginationEnabled: boolean,
-	config: {
-		prev?: PrevNextLinkConfig;
-		next?: PrevNextLinkConfig;
-	}
+  sidebar: SidebarEntry[],
+  paginationEnabled: boolean,
+  config: {
+    prev?: PrevNextLinkConfig;
+    next?: PrevNextLinkConfig;
+  }
 ): PaginationLinks {
-	const entries = flattenSidebar(sidebar);
-	const currentIndex = entries.findIndex((entry) => entry.isCurrent);
-	const prev = applyPrevNextLinkConfig(entries[currentIndex - 1], paginationEnabled, config.prev);
-	const next = applyPrevNextLinkConfig(
-		currentIndex > -1 ? entries[currentIndex + 1] : undefined,
-		paginationEnabled,
-		config.next
-	);
-	return { prev, next };
+  const entries = flattenSidebar(sidebar);
+  const currentIndex = entries.findIndex((entry) => entry.isCurrent);
+  const prev = applyPrevNextLinkConfig(entries[currentIndex - 1], paginationEnabled, config.prev);
+  const next = applyPrevNextLinkConfig(
+    currentIndex > -1 ? entries[currentIndex + 1] : undefined,
+    paginationEnabled,
+    config.next
+  );
+  return { prev, next };
 }
 
 /** Apply a prev/next link config to a navigation link. */
 function applyPrevNextLinkConfig(
-	link: SidebarLink | undefined,
-	paginationEnabled: boolean,
-	config: PrevNextLinkConfig | undefined
+  link: SidebarLink | undefined,
+  paginationEnabled: boolean,
+  config: PrevNextLinkConfig | undefined
 ): SidebarLink | undefined {
-	// Explicitly remove the link.
-	if (config === false) return undefined;
-	// Use the generated link if any.
-	else if (config === true) return link;
-	// If a link exists, update its label if needed.
-	else if (typeof config === 'string' && link) {
-		return { ...link, label: config };
-	} else if (typeof config === 'object') {
-		if (link) {
-			// If a link exists, update both its label and href if needed.
-			return {
-				...link,
-				label: config.label ?? link.label,
-				href: config.link ?? link.href,
-				// Explicitly remove sidebar link attributes for prev/next links.
-				attrs: {},
-			};
-		} else if (config.link && config.label) {
-			// If there is no link and the frontmatter contains both a URL and a label,
-			// create a new link.
-			return makeLink({ href: config.link, label: config.label });
-		}
-	}
-	// Otherwise, if the global config is enabled, return the generated link if any.
-	return paginationEnabled ? link : undefined;
+  // Explicitly remove the link.
+  if (config === false) return undefined;
+  // Use the generated link if any.
+  else if (config === true) return link;
+  // If a link exists, update its label if needed.
+  else if (typeof config === "string" && link) {
+    return { ...link, label: config };
+  } else if (typeof config === "object") {
+    if (link) {
+      // If a link exists, update both its label and href if needed.
+      return {
+        ...link,
+        label: config.label ?? link.label,
+        href: config.link ?? link.href,
+        // Explicitly remove sidebar link attributes for prev/next links.
+        attrs: {},
+      };
+    } else if (config.link && config.label) {
+      // If there is no link and the frontmatter contains both a URL and a label,
+      // create a new link.
+      return makeLink({ href: config.link, label: config.label });
+    }
+  }
+  // Otherwise, if the global config is enabled, return the generated link if any.
+  return paginationEnabled ? link : undefined;
 }
 
 /** Get a sidebar badge for a given item. */
 function getSidebarBadge(
-	config: I18nBadgeConfig,
-	locale: string | undefined,
-	itemLabel: string
+  config: I18nBadgeConfig,
+  locale: string | undefined,
+  itemLabel: string
 ): Badge | undefined {
-	if (!config) return;
-	if (typeof config === 'string') {
-		return { variant: 'default', text: config };
-	}
-	return { ...config, text: getSidebarBadgeText(config.text, locale, itemLabel) };
+  if (!config) return;
+  if (typeof config === "string") {
+    return { variant: "default", text: config };
+  }
+  return { ...config, text: getSidebarBadgeText(config.text, locale, itemLabel) };
 }
 
 /** Get the badge text for a sidebar item. */
 function getSidebarBadgeText(
-	text: I18nBadge['text'],
-	locale: string | undefined,
-	itemLabel: string
+  text: I18nBadge["text"],
+  locale: string | undefined,
+  itemLabel: string
 ): string {
-	if (typeof text === 'string') return text;
-	const defaultLang =
-		config.defaultLocale?.lang || config.defaultLocale?.locale || BuiltInDefaultLocale.lang;
-	const defaultText = text[defaultLang];
-
-	if (!defaultText) {
-		throw new AstroError(
-			`The badge text for "${itemLabel}" must have a key for the default language "${defaultLang}".`,
-			'Update the Starlight config to include a badge text for the default language.\n' +
-				'Learn more about sidebar badges internationalization at https://starlight.astro.build/guides/sidebar/#internationalization-with-badges'
-		);
-	}
-
-	return pickLang(text, localeToLang(locale)) || defaultText;
+  if (typeof text === "string") return text;
+  const defaultLang =
+    config.defaultLocale?.lang || config.defaultLocale?.locale || BuiltInDefaultLocale.lang;
+  const defaultText = text[defaultLang];
+
+  if (!defaultText) {
+    throw new AstroError(
+      `The badge text for "${itemLabel}" must have a key for the default language "${defaultLang}".`,
+      "Update the Starlight config to include a badge text for the default language.\n" +
+        "Learn more about sidebar badges internationalization at https://starlight.astro.build/guides/sidebar/#internationalization-with-badges"
+    );
+  }
+
+  return pickLang(text, localeToLang(locale)) || defaultText;
 }
diff --git a/utils/routing/index.ts b/utils/routing/index.ts
index 460d15a778f3ea47e8df62bf8d217edf4b482e34..739010811a26ab189f3404d44c3ef7c1e922f9f6 100644
--- a/utils/routing/index.ts
+++ b/utils/routing/index.ts
@@ -1,20 +1,20 @@
-import type { GetStaticPathsItem } from 'astro';
-import { getCollection } from 'astro:content';
-import config from 'virtual:starlight/user-config';
-import project from 'virtual:starlight/project-context';
-import { getCollectionPathFromRoot } from '../collection';
-import { localizedId, localizedSlug, slugToLocaleData, slugToParam } from '../slugs';
-import { validateLogoImports } from '../validateLogoImports';
-import { BuiltInDefaultLocale } from '../i18n';
-import type { Route, StarlightDocsCollectionEntry, StarlightDocsEntry } from './types';
+import type { GetStaticPathsItem } from "astro";
+import { getCollection } from "astro:content";
+import config from "virtual:starlight/user-config";
+import project from "virtual:starlight/project-context";
+import { getCollectionPathFromRoot } from "../collection";
+import { localizedId, localizedSlug, slugToLocaleData, slugToParam } from "../slugs";
+import { validateLogoImports } from "../validateLogoImports";
+import { BuiltInDefaultLocale } from "../i18n";
+import type { Route, StarlightDocsCollectionEntry, StarlightDocsEntry } from "./types";
 
 // Validate any user-provided logos imported correctly.
 // We do this here so all pages trigger it and at the top level so it runs just once.
 validateLogoImports();
 
 interface Path extends GetStaticPathsItem {
-	params: { slug: string | undefined };
-	props: Route;
+  params: { slug: string | undefined };
+  props: Route;
 }
 
 /**
@@ -22,92 +22,100 @@ interface Path extends GetStaticPathsItem {
  * `index` is stripped, but in the root of a collection, we get a slug of `index`.
  * We map that to an empty string for consistent behaviour.
  */
-const normalizeIndexSlug = (slug: string) => (slug === 'index' ? '' : slug);
+const normalizeIndexSlug = (slug: string) => (slug === "index" ? "" : slug);
 
 /** Normalize the different collection entry we can get from a legacy collection or a loader. */
 export function normalizeCollectionEntry(entry: StarlightDocsCollectionEntry): StarlightDocsEntry {
-	const slug = normalizeIndexSlug(entry.slug ?? entry.id);
-	return {
-		...entry,
-		// In a collection with a loader, the `id` is a slug and should be normalized.
-		id: entry.slug ? entry.id : slug,
-		// In a legacy collection, the `filePath` property doesn't exist.
-		filePath: entry.filePath ?? `${getCollectionPathFromRoot('docs', project)}/${entry.id}`,
-		// In a collection with a loader, the `slug` property is replaced by the `id`.
-		slug: normalizeIndexSlug(entry.slug ?? entry.id),
-	};
+  const slug = normalizeIndexSlug(entry.slug ?? entry.id);
+  return {
+    ...entry,
+    // In a collection with a loader, the `id` is a slug and should be normalized.
+    id: entry.slug ? entry.id : slug,
+    // In a legacy collection, the `filePath` property doesn't exist.
+    filePath: entry.filePath ?? `${getCollectionPathFromRoot("docs", project)}/${entry.id}`,
+    // In a collection with a loader, the `slug` property is replaced by the `id`.
+    slug: normalizeIndexSlug(entry.slug ?? entry.id),
+  };
 }
 
 /** All entries in the docs content collection. */
 const docs: StarlightDocsEntry[] = (
-	(await getCollection('docs', ({ data }) => {
-		// In production, filter out drafts.
-		return import.meta.env.MODE !== 'production' || data.draft === false;
-	})) ?? []
+  (await getCollection("docs", ({ data }) => {
+    // In production, filter out drafts.
+    return import.meta.env.MODE !== "production" || data.draft === false;
+  })) ?? []
 ).map(normalizeCollectionEntry);
 
+function cleanSegment(path: string): string {
+  let segments = path.split("/");
+  if (segments[0] === segments[2]) {
+    segments.splice(2, 1); // Remove the third segment (index 2)
+  }
+  return segments.join("/"); // Join the segments back into a string
+}
+
 function getRoutes(): Route[] {
-	const routes: Route[] = docs.map((entry) => ({
-		entry,
-		slug: entry.slug,
-		id: entry.id,
-		entryMeta: slugToLocaleData(entry.slug),
-		...slugToLocaleData(entry.slug),
-	}));
+  const routes: Route[] = docs.map((entry) => ({
+    entry: { ...entry, id: cleanSegment(entry.id), slug: cleanSegment(entry.slug) },
+    slug: cleanSegment(entry.slug),
+    id: cleanSegment(entry.id),
+    entryMeta: slugToLocaleData(cleanSegment(entry.slug)),
+    ...slugToLocaleData(cleanSegment(entry.slug)),
+  }));
 
-	// In multilingual sites, add required fallback routes.
-	if (config.isMultilingual) {
-		/** Entries in the docs content collection for the default locale. */
-		const defaultLocaleDocs = getLocaleDocs(
-			config.defaultLocale?.locale === 'root' ? undefined : config.defaultLocale?.locale
-		);
-		for (const key in config.locales) {
-			if (key === config.defaultLocale.locale) continue;
-			const localeConfig = config.locales[key];
-			if (!localeConfig) continue;
-			const locale = key === 'root' ? undefined : key;
-			const localeDocs = getLocaleDocs(locale);
-			for (const fallback of defaultLocaleDocs) {
-				const slug = localizedSlug(fallback.slug, locale);
-				const id = project.legacyCollections ? localizedId(fallback.id, locale) : slug;
-				const doesNotNeedFallback = localeDocs.some((doc) => doc.slug === slug);
-				if (doesNotNeedFallback) continue;
-				routes.push({
-					entry: fallback,
-					slug,
-					id,
-					isFallback: true,
-					lang: localeConfig.lang || BuiltInDefaultLocale.lang,
-					locale,
-					dir: localeConfig.dir,
-					entryMeta: slugToLocaleData(fallback.slug),
-				});
-			}
-		}
-	}
+  // In multilingual sites, add required fallback routes.
+  if (config.isMultilingual) {
+    /** Entries in the docs content collection for the default locale. */
+    const defaultLocaleDocs = getLocaleDocs(
+      config.defaultLocale?.locale === "root" ? undefined : config.defaultLocale?.locale
+    );
+    for (const key in config.locales) {
+      if (key === config.defaultLocale.locale) continue;
+      const localeConfig = config.locales[key];
+      if (!localeConfig) continue;
+      const locale = key === "root" ? undefined : key;
+      const localeDocs = getLocaleDocs(locale);
+      for (const fallback of defaultLocaleDocs) {
+        const slug = localizedSlug(fallback.slug, locale);
+        const id = project.legacyCollections ? localizedId(fallback.id, locale) : slug;
+        const doesNotNeedFallback = localeDocs.some((doc) => doc.slug === slug);
+        if (doesNotNeedFallback) continue;
+        routes.push({
+          entry: fallback,
+          slug,
+          id,
+          isFallback: true,
+          lang: localeConfig.lang || BuiltInDefaultLocale.lang,
+          locale,
+          dir: localeConfig.dir,
+          entryMeta: slugToLocaleData(fallback.slug),
+        });
+      }
+    }
+  }
 
-	return routes;
+  return routes;
 }
 export const routes = getRoutes();
 
 function getParamRouteMapping(): ReadonlyMap<string | undefined, Route> {
-	const map = new Map<string | undefined, Route>();
-	for (const route of routes) {
-		map.set(slugToParam(route.slug), route);
-	}
-	return map;
+  const map = new Map<string | undefined, Route>();
+  for (const route of routes) {
+    map.set(slugToParam(route.slug), route);
+  }
+  return map;
 }
 const routesBySlugParam = getParamRouteMapping();
 
 export function getRouteBySlugParam(slugParam: string | undefined): Route | undefined {
-	return routesBySlugParam.get(slugParam?.replace(/\/$/, '') || undefined);
+  return routesBySlugParam.get(slugParam?.replace(/\/$/, "") || undefined);
 }
 
 function getPaths(): Path[] {
-	return routes.map((route) => ({
-		params: { slug: slugToParam(route.slug) },
-		props: route,
-	}));
+  return routes.map((route) => ({
+    params: { slug: slugToParam(route.slug) },
+    props: route,
+  }));
 }
 export const paths = getPaths();
 
@@ -116,7 +124,7 @@ export const paths = getPaths();
  * A locale of `undefined` is treated as the “root” locale, if configured.
  */
 export function getLocaleRoutes(locale: string | undefined): Route[] {
-	return filterByLocale(routes, locale);
+  return filterByLocale(routes, locale);
 }
 
 /**
@@ -124,20 +132,20 @@ export function getLocaleRoutes(locale: string | undefined): Route[] {
  * A locale of `undefined` is treated as the “root” locale, if configured.
  */
 function getLocaleDocs(locale: string | undefined): StarlightDocsEntry[] {
-	return filterByLocale(docs, locale);
+  return filterByLocale(docs, locale);
 }
 
 /** Filter an array to find items whose slug matches the passed locale. */
 function filterByLocale<T extends { slug: string }>(items: T[], locale: string | undefined): T[] {
-	if (config.locales) {
-		if (locale && locale in config.locales) {
-			return items.filter((i) => i.slug === locale || i.slug.startsWith(locale + '/'));
-		} else if (config.locales.root) {
-			const langKeys = Object.keys(config.locales).filter((k) => k !== 'root');
-			const isLangIndex = new RegExp(`^(${langKeys.join('|')})$`);
-			const isLangDir = new RegExp(`^(${langKeys.join('|')})/`);
-			return items.filter((i) => !isLangIndex.test(i.slug) && !isLangDir.test(i.slug));
-		}
-	}
-	return items;
+  if (config.locales) {
+    if (locale && locale in config.locales) {
+      return items.filter((i) => i.slug === locale || i.slug.startsWith(locale + "/"));
+    } else if (config.locales.root) {
+      const langKeys = Object.keys(config.locales).filter((k) => k !== "root");
+      const isLangIndex = new RegExp(`^(${langKeys.join("|")})$`);
+      const isLangDir = new RegExp(`^(${langKeys.join("|")})/`);
+      return items.filter((i) => !isLangIndex.test(i.slug) && !isLangDir.test(i.slug));
+    }
+  }
+  return items;
 }
