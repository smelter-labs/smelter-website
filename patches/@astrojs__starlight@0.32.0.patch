diff --git a/utils/createPathFormatter.ts b/utils/createPathFormatter.ts
index 52c9527c6d8c6756125c2f746cf14d055ed1e3ef..8dd709f556b94a578636835ea9a9382921dfe3eb 100644
--- a/utils/createPathFormatter.ts
+++ b/utils/createPathFormatter.ts
@@ -37,9 +37,15 @@ function formatPath(
 	href: string,
 	{ format = 'directory', trailingSlash = 'ignore' }: FormatPathOptions
 ) {
+	const segments = href.split('/');
 	const formatStrategy = formatStrategies[format];
 	const trailingSlashStrategy = trailingSlashStrategies[trailingSlash];
 
+	if (segments[1] === segments[3]) {
+	  segments.splice(3, 1);
+	  href = segments.join('/')
+	}	
+
 	// Handle extension
 	href = formatStrategy.handleExtension(href);
 
diff --git a/utils/navigation.ts b/utils/navigation.ts
index cfcd2e837d328fb0f15c7706862f115a184e2ff3..fa528c286149ab9543bc5a8582675f33f0873c1a 100644
--- a/utils/navigation.ts
+++ b/utils/navigation.ts
@@ -224,10 +224,35 @@ function getRoutePathRelativeToCollectionRoot(route: Route, locale: string | und
 			localizedId(route.entry.filePath.replace(`${docsCollectionPathFromRoot}/`, ''), locale);
 }
 
+function cleanSegment(path: string): string {
+    let segments = path.split('/');
+    if (segments[0] === segments[2]) {
+        segments.splice(2, 1);  // Remove the third segment (index 2)
+    }
+    return segments.join('/');  // Join the segments back into a string
+}
+
 /** Turn a flat array of routes into a tree structure. */
 function treeify(routes: Route[], locale: string | undefined, baseDir: string): Dir {
 	const treeRoot: Dir = makeDir(baseDir);
-	routes
+
+	const testRoutes = routes.map(item => {
+    		let newItem = {...item, entry: {...item.entry}};
+
+			if (newItem.id) newItem.id = cleanSegment(newItem.id);
+    		if (newItem.slug) newItem.slug = cleanSegment(newItem.slug);
+
+    		// Also handle id and slug inside entry if it exists
+    		if (newItem.entry) {
+    		    newItem.entry = { ...newItem.entry };
+    		    newItem.entry.id = cleanSegment(newItem.entry.id);
+    		    newItem.entry.slug = cleanSegment(newItem.entry.slug);
+    		}
+
+    		return newItem; 
+		}) 
+		
+	testRoutes
 		// Remove any entries that should be hidden
 		.filter((doc) => !doc.entry.data.sidebar.hidden)
 		// Compute the path of each entry from the root of the collection ahead of time.
diff --git a/utils/routing/index.ts b/utils/routing/index.ts
index 460d15a778f3ea47e8df62bf8d217edf4b482e34..79248ae4a64c608b7b72577b8b6670f6ffa592e2 100644
--- a/utils/routing/index.ts
+++ b/utils/routing/index.ts
@@ -1,20 +1,29 @@
-import type { GetStaticPathsItem } from 'astro';
-import { getCollection } from 'astro:content';
-import config from 'virtual:starlight/user-config';
-import project from 'virtual:starlight/project-context';
-import { getCollectionPathFromRoot } from '../collection';
-import { localizedId, localizedSlug, slugToLocaleData, slugToParam } from '../slugs';
-import { validateLogoImports } from '../validateLogoImports';
-import { BuiltInDefaultLocale } from '../i18n';
-import type { Route, StarlightDocsCollectionEntry, StarlightDocsEntry } from './types';
+import type { GetStaticPathsItem } from "astro";
+import { getCollection } from "astro:content";
+import config from "virtual:starlight/user-config";
+import project from "virtual:starlight/project-context";
+import { getCollectionPathFromRoot } from "../collection";
+import {
+  localizedId,
+  localizedSlug,
+  slugToLocaleData,
+  slugToParam,
+} from "../slugs";
+import { validateLogoImports } from "../validateLogoImports";
+import { BuiltInDefaultLocale } from "../i18n";
+import type {
+  Route,
+  StarlightDocsCollectionEntry,
+  StarlightDocsEntry,
+} from "./types";
 
 // Validate any user-provided logos imported correctly.
 // We do this here so all pages trigger it and at the top level so it runs just once.
 validateLogoImports();
 
 interface Path extends GetStaticPathsItem {
-	params: { slug: string | undefined };
-	props: Route;
+  params: { slug: string | undefined };
+  props: Route;
 }
 
 /**
@@ -22,92 +31,110 @@ interface Path extends GetStaticPathsItem {
  * `index` is stripped, but in the root of a collection, we get a slug of `index`.
  * We map that to an empty string for consistent behaviour.
  */
-const normalizeIndexSlug = (slug: string) => (slug === 'index' ? '' : slug);
+const normalizeIndexSlug = (slug: string) => (slug === "index" ? "" : slug);
 
 /** Normalize the different collection entry we can get from a legacy collection or a loader. */
-export function normalizeCollectionEntry(entry: StarlightDocsCollectionEntry): StarlightDocsEntry {
-	const slug = normalizeIndexSlug(entry.slug ?? entry.id);
-	return {
-		...entry,
-		// In a collection with a loader, the `id` is a slug and should be normalized.
-		id: entry.slug ? entry.id : slug,
-		// In a legacy collection, the `filePath` property doesn't exist.
-		filePath: entry.filePath ?? `${getCollectionPathFromRoot('docs', project)}/${entry.id}`,
-		// In a collection with a loader, the `slug` property is replaced by the `id`.
-		slug: normalizeIndexSlug(entry.slug ?? entry.id),
-	};
+export function normalizeCollectionEntry(
+  entry: StarlightDocsCollectionEntry
+): StarlightDocsEntry {
+  const slug = normalizeIndexSlug(entry.slug ?? entry.id);
+  return {
+    ...entry,
+    // In a collection with a loader, the `id` is a slug and should be normalized.
+    id: entry.slug ? entry.id : slug,
+    // In a legacy collection, the `filePath` property doesn't exist.
+    filePath:
+      entry.filePath ??
+      `${getCollectionPathFromRoot("docs", project)}/${entry.id}`,
+    // In a collection with a loader, the `slug` property is replaced by the `id`.
+    slug: normalizeIndexSlug(entry.slug ?? entry.id),
+  };
 }
 
 /** All entries in the docs content collection. */
 const docs: StarlightDocsEntry[] = (
-	(await getCollection('docs', ({ data }) => {
-		// In production, filter out drafts.
-		return import.meta.env.MODE !== 'production' || data.draft === false;
-	})) ?? []
+  (await getCollection("docs", ({ data }) => {
+    // In production, filter out drafts.
+    return import.meta.env.MODE !== "production" || data.draft === false;
+  })) ?? []
 ).map(normalizeCollectionEntry);
 
+function cleanSegment(path: string): string {
+  let segments = path.split("/");
+  if (segments[0] === segments[2]) {
+    segments.splice(2, 1); // Remove the third segment (index 2)
+  }
+  return segments.join("/"); // Join the segments back into a string
+}
+
 function getRoutes(): Route[] {
-	const routes: Route[] = docs.map((entry) => ({
-		entry,
-		slug: entry.slug,
-		id: entry.id,
-		entryMeta: slugToLocaleData(entry.slug),
-		...slugToLocaleData(entry.slug),
-	}));
+  const routes: Route[] = docs.map((entry) => ({
+    entry: {...entry, id: cleanSegment(entry.id), slug: cleanSegment(entry.slug)},
+    slug: cleanSegment(entry.slug),
+    id: cleanSegment(entry.id),
+    entryMeta: slugToLocaleData(cleanSegment(entry.slug)),
+    ...slugToLocaleData(cleanSegment(entry.slug)),
+  }));
 
-	// In multilingual sites, add required fallback routes.
-	if (config.isMultilingual) {
-		/** Entries in the docs content collection for the default locale. */
-		const defaultLocaleDocs = getLocaleDocs(
-			config.defaultLocale?.locale === 'root' ? undefined : config.defaultLocale?.locale
-		);
-		for (const key in config.locales) {
-			if (key === config.defaultLocale.locale) continue;
-			const localeConfig = config.locales[key];
-			if (!localeConfig) continue;
-			const locale = key === 'root' ? undefined : key;
-			const localeDocs = getLocaleDocs(locale);
-			for (const fallback of defaultLocaleDocs) {
-				const slug = localizedSlug(fallback.slug, locale);
-				const id = project.legacyCollections ? localizedId(fallback.id, locale) : slug;
-				const doesNotNeedFallback = localeDocs.some((doc) => doc.slug === slug);
-				if (doesNotNeedFallback) continue;
-				routes.push({
-					entry: fallback,
-					slug,
-					id,
-					isFallback: true,
-					lang: localeConfig.lang || BuiltInDefaultLocale.lang,
-					locale,
-					dir: localeConfig.dir,
-					entryMeta: slugToLocaleData(fallback.slug),
-				});
-			}
-		}
-	}
+  // In multilingual sites, add required fallback routes.
+  if (config.isMultilingual) {
+    /** Entries in the docs content collection for the default locale. */
+    const defaultLocaleDocs = getLocaleDocs(
+      config.defaultLocale?.locale === "root"
+        ? undefined
+        : config.defaultLocale?.locale
+    );
+    for (const key in config.locales) {
+      if (key === config.defaultLocale.locale) continue;
+      const localeConfig = config.locales[key];
+      if (!localeConfig) continue;
+      const locale = key === "root" ? undefined : key;
+      const localeDocs = getLocaleDocs(locale);
+      for (const fallback of defaultLocaleDocs) {
+        const slug = localizedSlug(fallback.slug, locale);
+        const id = project.legacyCollections
+          ? localizedId(fallback.id, locale)
+          : slug;
+        const doesNotNeedFallback = localeDocs.some((doc) => doc.slug === slug);
+        if (doesNotNeedFallback) continue;
+        routes.push({
+          entry: fallback,
+          slug,
+          id,
+          isFallback: true,
+          lang: localeConfig.lang || BuiltInDefaultLocale.lang,
+          locale,
+          dir: localeConfig.dir,
+          entryMeta: slugToLocaleData(fallback.slug),
+        });
+      }
+    }
+  }
 
-	return routes;
+  return routes;
 }
 export const routes = getRoutes();
 
 function getParamRouteMapping(): ReadonlyMap<string | undefined, Route> {
-	const map = new Map<string | undefined, Route>();
-	for (const route of routes) {
-		map.set(slugToParam(route.slug), route);
-	}
-	return map;
+  const map = new Map<string | undefined, Route>();
+  for (const route of routes) {
+    map.set(slugToParam(route.slug), route);
+  }
+  return map;
 }
 const routesBySlugParam = getParamRouteMapping();
 
-export function getRouteBySlugParam(slugParam: string | undefined): Route | undefined {
-	return routesBySlugParam.get(slugParam?.replace(/\/$/, '') || undefined);
+export function getRouteBySlugParam(
+  slugParam: string | undefined
+): Route | undefined {
+  return routesBySlugParam.get(slugParam?.replace(/\/$/, "") || undefined);
 }
 
 function getPaths(): Path[] {
-	return routes.map((route) => ({
-		params: { slug: slugToParam(route.slug) },
-		props: route,
-	}));
+  return routes.map((route) => ({
+    params: { slug: slugToParam(route.slug) },
+    props: route,
+  }));
 }
 export const paths = getPaths();
 
@@ -116,7 +143,7 @@ export const paths = getPaths();
  * A locale of `undefined` is treated as the “root” locale, if configured.
  */
 export function getLocaleRoutes(locale: string | undefined): Route[] {
-	return filterByLocale(routes, locale);
+  return filterByLocale(routes, locale);
 }
 
 /**
@@ -124,20 +151,27 @@ export function getLocaleRoutes(locale: string | undefined): Route[] {
  * A locale of `undefined` is treated as the “root” locale, if configured.
  */
 function getLocaleDocs(locale: string | undefined): StarlightDocsEntry[] {
-	return filterByLocale(docs, locale);
+  return filterByLocale(docs, locale);
 }
 
 /** Filter an array to find items whose slug matches the passed locale. */
-function filterByLocale<T extends { slug: string }>(items: T[], locale: string | undefined): T[] {
-	if (config.locales) {
-		if (locale && locale in config.locales) {
-			return items.filter((i) => i.slug === locale || i.slug.startsWith(locale + '/'));
-		} else if (config.locales.root) {
-			const langKeys = Object.keys(config.locales).filter((k) => k !== 'root');
-			const isLangIndex = new RegExp(`^(${langKeys.join('|')})$`);
-			const isLangDir = new RegExp(`^(${langKeys.join('|')})/`);
-			return items.filter((i) => !isLangIndex.test(i.slug) && !isLangDir.test(i.slug));
-		}
-	}
-	return items;
+function filterByLocale<T extends { slug: string }>(
+  items: T[],
+  locale: string | undefined
+): T[] {
+  if (config.locales) {
+    if (locale && locale in config.locales) {
+      return items.filter(
+        (i) => i.slug === locale || i.slug.startsWith(locale + "/")
+      );
+    } else if (config.locales.root) {
+      const langKeys = Object.keys(config.locales).filter((k) => k !== "root");
+      const isLangIndex = new RegExp(`^(${langKeys.join("|")})$`);
+      const isLangDir = new RegExp(`^(${langKeys.join("|")})/`);
+      return items.filter(
+        (i) => !isLangIndex.test(i.slug) && !isLangDir.test(i.slug)
+      );
+    }
+  }
+  return items;
 }
