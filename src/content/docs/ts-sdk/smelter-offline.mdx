---
title: OfflineSmelter
---
import { Code, Aside } from '@astrojs/starlight/components';
import CollapsibleDetails from '@components/CollapsibleDetails.astro';

<Code code={`import { OfflineSmelter } from "@swmansion/smelter-node"`} lang="tsx" />

`OfflineSmelter` is intended for [offline processing](/fundamentals/glossary#offline-processing) e.g. if you need to combine few mp4 files together.
It has simplified API compared to the [`Smelter`](/ts-sdk/smelter) class, optimized for rendering just one output file as a result.

## new Smelter()
Creates a new offline smelter instance. You have to call [`init()`](#init) first before this object can be used.

<Code code={`new OfflineSmelter(manager?: SmelterManager)`} lang="tsx" />

<CollapsibleDetails summaryTitle='Type definitions'>
```tsx
  type ApiRequest = {
    method: 'GET' | 'POST';
    route: string;
    body?: object;
  };

  type MultipartRequest = {
    method: 'POST';
    route: string;
    body: any;
  };

  type SmelterManager = {
    setupInstance(): Promise<void>;
    sendRequest(request: ApiRequest): Promise<object>;
    sendMultipartRequest(request: MultipartRequest): Promise<object>;
    registerEventListener(cb: (event: unknown) => void): void;
  }
```
</CollapsibleDetails>

### Parameters

#### manager
Configures how the client code will connect and manage a Smelter server. Smelter SDK provides 2 implementations that you can use or extend:
- [`LocallySpawnedInstnaceManager`](/ts-sdk/managers/node-locally-spawned) (**Default Configuration**) - Automatically download the necessary Smelter binaries and launch the server on your local machine.
- [`ExistingInstanceManager`](/ts-sdk/managers/node-existing-instance) - Connect to a smelter server instance that is already running.

<br/>

- **Type**: [`SmelterManager`](#new-smelter)

## init()
<Code code={`Smelter.init(): Promise<void>`} lang="tsx" />

Initialize the Smelter instance. This might spawn a new instance or just establish a connection, depending on the `manager` used while creating Smelter instance.

After `init()` you can start connecting inputs/outputs or register other elements. However, no output stream will be produced until `start()` method is called.

## render()
```tsx
import React from "react";

Smelter.render(
    root: React.ReactElement,
    output: RegisterOutput,
): Promise<object>
```
<CollapsibleDetails summaryTitle='Type definitions'>
```tsx
import {
    RegisterRtpOutput,
    RegisterMp4Output,
    RegisterHlsOutput,
    RegisterWhipClientOutput,
    RegisterWhepServerOutput,
    RegisterRtmpClientOutput,
} from "@swmasnion/smelter"

type RegisterOutput =
    | ({ type: 'rtp_stream' } & RegisterRtpOutput)
    | ({ type: 'mp4' } & RegisterMp4Output)
    | ({ type: 'hls' } & RegisterHlsOutput)
    | ({ type: 'whip_client' } & RegisterWhipClientOutput)
    | ({ type: 'whep_server' } & RegisterWhepServerOutput)
    | ({ type: 'rtmp_client' } & RegisterRtmpClientOutput);
```
</CollapsibleDetails>

Register external destination that can be used as a smelter output. Visit output documentation to learn more:
- [MP4](/ts-sdk/outputs/mp4)
- [HLS](/ts-sdk/outputs/hls)

<Aside type="note">
[WHIP](/ts-sdk/outputs/whip), [WHEP](/ts-sdk/outputs/whep), [RTMP](/ts-sdk/outputs/rtmp) and [RTP](/ts-sdk/outputs/rtp) are also supported,
but since the compositor produces frames as fast as possible, these real-time protocols, in most cases, would not make sense.
</Aside>

## registerInput()
```tsx
import { Inputs } from "@swmasnion/smelter"

Smelter.registerInput(
    inputId: string,
    input: Inputs.RegisterInput,
): Promise<object>
```
<CollapsibleDetails summaryTitle='Type definitions'>
```tsx
import {
    RegisterRtpInput,
    RegisterMp4Input,
    RegisterHlsInput,
    RegisterWhipServerInput,
    RegisterWhepClientInput,
} from "@swmasnion/smelter"

type RegisterInput =
    | ({ type: 'rtp_stream' } & RegisterRtpInput)
    | ({ type: 'mp4' } & RegisterMp4Input)
    | ({ type: 'hls' } & RegisterHlsInput)
    | ({ type: 'whip_server' } & RegisterWhipServerInput)
    | ({ type: 'whep_client' } & RegisterWhepClientInput);
```
</CollapsibleDetails>

Register external source that can be used as a smelter input. Visit input documentation to learn more:
- [RTP](/ts-sdk/inputs/rtp)
- [MP4](/ts-sdk/inputs/mp4)
- [HLS](/ts-sdk/inputs/hls)
- [WHEP](/ts-sdk/inputs/whep)
- [WHIP](/ts-sdk/inputs/whip)

<Aside type="caution">
Remember that in this mode compositor will consume input frames as fast as possible. Protocols like RTP or WHIP
can technically be used as input, but in most cases it would limit processing back to real-time.
</Aside>

## registerImage()
```tsx
import { Renderers } from "@swmansion/smelter"

Smelter.registerImage(
    imageId: string,
    image: Renderers.RegisterImage,
): Promise<void>
```

Register an image asset. See [RegisterImage](/ts-sdk/resources/image) to learn more.

## registerShader()
```tsx
import { Renderers } from "@swmnasion/smelter"

Smelter.registerShader(
    shaderId: string,
    shader: Renderers.RegisterShader,
): Promise<void>
```

Register a shader. See [RegisterShader](/ts-sdk/resources/shader) to learn more.

## registerFont()
<Code code={`Smelter.registerFont(source: string | ArrayBuffer): Promise<void>`} lang="tsx" />

Register new font.
