---
import { Image } from "astro:assets";
import CapabilitiesItem from "./CapabilitiesItem.astro";

import api from "../../assets/capabilities/api.svg";
import battery from "../../assets/capabilities/battery.svg";
import bolt from "../../assets/capabilities/bolt.svg";
import capabilitiesBlur from "../../assets/capabilities/capabilities-blur2.svg";
import wavePattern from "../../assets/capabilities/capabilities-wave.svg";
import flexbility from "../../assets/capabilities/flexbility.svg";
import offline from "../../assets/capabilities/offline.svg";
import sliders from "../../assets/capabilities/sliders.svg";

const CAPABILITIES = [
	{
		label: "Simple, declarative API",
		text: "You can easily mix streams with an intuitive component tree. Smelter is quick to pick up for anyone familiar with web development.",
		icon: api,
	},
	{
		label: "Unmatched flexibility",
		text: "The API is language-agnostic and fits right into the existing setup. It operates across the web, server environments, and supports a range of protocols.",
		icon: flexbility,
	},
	{
		label: "Real-time and low latency",
		text: "Smelter targets real-time use cases, where latency is measured in milliseconds. It ensures seamless performance for applications that demand immediate responsiveness.",
		icon: bolt,
	},
	{
		label: "Batteries included",
		text: "The tool lets you process streams, render text, images, GIFs, or websites, and combine them using high-level components. Plus, with our animated transitions, you can change layouts on the fly.",
		icon: battery,
	},
	{
		label: "Highly customizable",
		text: "Choose from pre-built options or create custom effects with WGSL shaders and directly leverage GPU parallel processing capabilities.",
		icon: sliders,
	},
	{
		label: "Offline processing available",
		text: " With Smelter, you can also handle non-real-time scenarios by enabling offline processing. This allows you to process content asynchronously, giving you more flexibility for tasks that donâ€™t require immediate results.",
		icon: offline,
	},
] as const;
---

<section class="mx-40 flex flex-col items-center px-16 relative mb-28">
  <Image id="capabilitiesWave" src={wavePattern} alt="wave pattern" class="absolute top-36 -right-40 -z-10" />
  <Image id="capabilitiesBlur" src={capabilitiesBlur} alt="gradient" class="absolute -bottom-52 -left-40 -translate-x-1/2 -z-10" />
  <h2 class="mb-2 text-capabilities-header">Live stream mixing simplified</h2>
  <p class="text-capabilities-subheader">Simple, powerful, fast</p>
  <div class="mt-20 flex gap-6 overflow-hidden relative">
    <div class="flex flex-1 flex-col gap-y-6">
      {
        CAPABILITIES.filter((_, index) => !(index % 2)).map(capability => (
          <CapabilitiesItem {...capability} />
        ))
      }
    </div>
    <div class="flex flex-1 flex-col gap-y-6 mt-1/6">
      {
        CAPABILITIES.filter((_, index) => index % 2).map(capability => (
          <CapabilitiesItem {...capability} />
        ))
      }
    </div>
  </div>
</section>


<script type="module">
  document.addEventListener('DOMContentLoaded', function () {
    const capabilitiesBlur = document.getElementById('capabilitiesBlur');
	const capabilitiesWave = document.getElementById('capabilitiesWave');
    
	const parentSection = capabilitiesBlur.closest('section');

    const handleScroll = () => {
        const sectionBottom = parentSection.getBoundingClientRect().bottom;
        const scrollY = window.screenY;
        const sectionBottomToPageTop = scrollY + sectionBottom;
        const relativeBottom = scrollY - sectionBottomToPageTop + window.innerHeight;
        
        if (relativeBottom > -window.innerHeight && sectionBottom < window.innerHeight) {
            const translateY = relativeBottom;
            capabilitiesBlur.style.transform = `translateY(-${translateY * 0.7}px) translateX(-50%)`;
			capabilitiesWave.style.transform = `translateY(${translateY * 0.4}px)`
        }
    };

  	window.addEventListener('scroll', handleScroll);
  });
</script>
